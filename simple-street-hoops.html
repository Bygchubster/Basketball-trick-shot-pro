<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Street Hoops</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&family=JetBrains+Mono:wght@700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #f3f4f6;
            font-family: 'Inter', sans-serif;
        }
        .font-mono {
            font-family: 'JetBrains Mono', monospace;
        }
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-25%); }
        }
        .animate-bounce {
            animation: bounce 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: .5; }
        }
        .animate-pulse {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
    </style>
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client"
      }
    }
    </script>
</head>
<body>
    <div id="root"></div>
    
    <script type="module">
        import React, { useState, useCallback, useRef, useEffect } from 'react';
        import ReactDOM from 'react-dom/client';

        // Types
        const InputState = {
          SETTING_ANGLE: 'SETTING_ANGLE',
          SETTING_POWER: 'SETTING_POWER',
          READY_TO_FIRE: 'READY_TO_FIRE',
          FLYING: 'FLYING'
        };

        // Gemini Service Mock
        const LOCAL_FALLBACKS = {
          "SCORED": ["Nothing but net!", "That's how we do it in the streets.", "Bucket! Keep 'em coming.", "Easy money.", "Smooth as butter.", "Automatic!", "He's heating up!"],
          "SWISH": ["Drained it! Clean!", "Swish! Perfection.", "That sound... pure music.", "Absolute laser focus.", "String music!", "Splashed it!"],
          "MISSED": ["Clank! Off the iron.", "Need more touch on that one.", "Brick city!", "Keep your head up, go again.", "Ice cold right now.", "Short! Adjust the power."],
          "LEVEL UP": ["Level Up! The stakes just got higher.", "New level, new obstacles. Stay focused.", "Moving on up! You're dominating the court.", "Level cleared! Let's see what's next."],
          "START": ["Welcome to the court. Let's see some game.", "Ball's in your court. Show me something.", "Don't let the pressure get to you."]
        };

        const fetchCommentary = async (event, score) => {
          let type = "SCORED";
          if (event.includes("LEVEL")) type = "LEVEL UP";
          else if (event.includes("SWISH")) type = "SWISH";
          else if (event.includes("MISSED")) type = "MISSED";
          else if (event.includes("START")) type = "START";
          
          const category = LOCAL_FALLBACKS[type] || LOCAL_FALLBACKS["SCORED"];
          return category[Math.floor(Math.random() * category.length)];
        };

        // Components
        const HUD = ({ gameState, isLoadingModifier, onBackToMenu }) => {
          return React.createElement('div', { className: "relative z-20 w-full max-w-4xl px-4 py-6 flex flex-col gap-6" },
            React.createElement('div', { className: "flex justify-between items-center" },
              React.createElement('div', { className: "flex gap-3" },
                React.createElement('button', { 
                  onClick: onBackToMenu,
                  className: "bg-slate-900 border-2 border-slate-900 p-3 rounded-xl shadow-lg hover:bg-slate-800 transition-colors group"
                },
                  React.createElement('p', { className: "text-[9px] text-slate-400 font-bold uppercase tracking-widest group-hover:text-orange-400 transition-colors" }, "Menu"),
                  React.createElement('div', { className: "flex items-center justify-center mt-1" },
                    React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", className: "h-6 w-6 text-white", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor" },
                      React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 3, d: "M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" })
                    )
                  )
                ),
                React.createElement('div', { className: "bg-slate-900 border-2 border-slate-900 p-3 rounded-xl shadow-lg min-w-[90px] text-center" },
                  React.createElement('p', { className: "text-[9px] text-slate-400 font-bold uppercase tracking-widest" }, "Score"),
                  React.createElement('p', { className: "text-3xl font-mono font-black text-white" }, gameState.score)
                ),
                React.createElement('div', { className: "bg-white border-2 border-slate-900 p-3 rounded-xl shadow-lg min-w-[90px] text-center" },
                  React.createElement('p', { className: "text-[9px] text-slate-500 font-bold uppercase tracking-widest" }, "Level"),
                  React.createElement('p', { className: "text-3xl font-mono font-black text-slate-900" }, gameState.level)
                )
              ),
              React.createElement('div', { className: "flex-1 px-8" },
                React.createElement('p', { className: "text-xl font-bold text-slate-800 italic text-center leading-tight" },
                  `"${gameState.commentary}"`
                )
              )
            )
          );
        };

        const Menu = ({ onSelectLevel }) => {
          const levels = Array.from({ length: 20 }, (_, i) => i + 1);

          const getLevelTag = (lvl) => {
            if (lvl === 1) return "TUTORIAL";
            if (lvl === 4) return "BOUNCE";
            if (lvl === 5) return "RICOCHET";
            if (lvl === 7) return "BOOST";
            if (lvl === 9) return "BOUNCY";
            if (lvl === 11) return "TRENCH";
            if (lvl === 12) return "ROTATOR";
            if (lvl === 13) return "ZIGZAG";
            if (lvl === 14) return "WINDOW";
            if (lvl === 15) return "TRICKSHOT";
            if (lvl === 16) return "CRUSHER";
            if (lvl === 17) return "PLINKO";
            if (lvl === 19) return "FAN";
            if (lvl === 20) return "MASTER";
            if (lvl > 15) return "HARD";
            if (lvl > 8) return "PRO";
            return "EASY";
          };

          return React.createElement('div', { className: "w-full h-full flex flex-col items-center justify-center bg-slate-100 overflow-y-auto py-12 px-6" },
            React.createElement('div', { className: "max-w-4xl w-full" },
              React.createElement('header', { className: "text-center mb-12" },
                React.createElement('h1', { className: "text-8xl font-black italic tracking-tighter text-slate-900 uppercase leading-none" },
                  "STREET",
                  React.createElement('br'),
                  "HOOPS"
                ),
                React.createElement('div', { className: "h-3 w-48 bg-orange-600 mx-auto mt-4 rounded-full" }),
                React.createElement('p', { className: "mt-6 text-slate-500 font-bold uppercase tracking-[0.3em] text-sm" }, "Select Your Level")
              ),
              React.createElement('div', { className: "grid grid-cols-2 md:grid-cols-4 lg:grid-cols-5 gap-4" },
                levels.map((lvl) =>
                  React.createElement('button', {
                    key: lvl,
                    onClick: () => onSelectLevel(lvl),
                    className: "group relative bg-white border-4 border-slate-900 rounded-2xl p-6 shadow-[8px_8px_0px_0px_rgba(15,23,42,1)] hover:shadow-none hover:translate-x-1 hover:translate-y-1 transition-all flex flex-col items-center justify-center aspect-square"
                  },
                    React.createElement('span', { className: "text-sm font-black text-slate-400 uppercase tracking-widest mb-1 group-hover:text-orange-600 transition-colors" }, "Lvl"),
                    React.createElement('span', { className: "text-5xl font-black text-slate-900 group-hover:scale-110 transition-transform" }, lvl),
                    React.createElement('div', { 
                      className: `mt-2 px-3 py-1 rounded-full text-[10px] font-black uppercase tracking-wider ${
                        lvl === 1 ? 'bg-green-100 text-green-700' : 
                        lvl === 20 ? 'bg-red-100 text-red-700 animate-pulse' : 
                        'bg-slate-100 text-slate-600'
                      }`
                    }, getLevelTag(lvl)),
                    React.createElement('div', { className: "absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity" },
                      React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", className: "h-5 w-5 text-orange-600", viewBox: "0 0 20 20", fill: "currentColor" },
                        React.createElement('path', { fillRule: "evenodd", d: "M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z", clipRule: "evenodd" })
                      )
                    )
                  )
                )
              ),
              React.createElement('footer', { className: "mt-16 text-center text-slate-400 font-medium" },
                React.createElement('p', { className: "text-xs uppercase tracking-widest" }, "Master the specific mechanics to beat each stage")
              )
            )
          );
        };

        const WinView = ({ score, attempts, onPlayAgain }) => {
          return React.createElement('div', { className: "w-full h-full flex flex-col items-center justify-center bg-slate-900 text-white overflow-hidden p-6 text-center" },
            React.createElement('div', { className: "max-w-md w-full animate-in fade-in zoom-in duration-700" },
              React.createElement('h1', { className: "text-8xl font-black italic tracking-tighter uppercase leading-none text-orange-600 mb-2" }, "YOU WIN"),
              React.createElement('div', { className: "h-2 w-full bg-white mb-8 rounded-full" }),
              React.createElement('p', { className: "text-xl font-bold text-slate-400 uppercase tracking-widest mb-12" }, "You are the king of the court"),
              React.createElement('div', { className: "grid grid-cols-2 gap-4 mb-12" },
                React.createElement('div', { className: "bg-slate-800 p-6 rounded-3xl border-2 border-slate-700" },
                  React.createElement('p', { className: "text-[10px] font-black uppercase tracking-widest text-slate-500 mb-1" }, "Final Score"),
                  React.createElement('p', { className: "text-5xl font-black italic" }, score)
                ),
                React.createElement('div', { className: "bg-slate-800 p-6 rounded-3xl border-2 border-slate-700" },
                  React.createElement('p', { className: "text-[10px] font-black uppercase tracking-widest text-slate-500 mb-1" }, "Total Shots"),
                  React.createElement('p', { className: "text-5xl font-black italic" }, attempts)
                )
              ),
              React.createElement('button', {
                onClick: onPlayAgain,
                className: "w-full py-6 bg-orange-600 hover:bg-orange-500 text-white rounded-3xl font-black text-2xl uppercase italic tracking-tighter shadow-[0px_10px_0px_0px_rgba(154,52,18,1)] hover:shadow-none hover:translate-y-2 transition-all"
              }, "Back to Menu"),
              React.createElement('p', { className: "mt-12 text-slate-600 font-bold uppercase tracking-[0.4em] text-[10px]" }, "Street Hoops Legacy • Champion")
            )
          );
        };

        // GameView Component - This is a large component, I'll create it inline
        const GameView = ({ gravity, level, wind, onScore, onMiss }) => {
          const canvasRef = useRef(null);
          const containerRef = useRef(null);
          
          const [inputState, setInputState] = useState(InputState.SETTING_ANGLE);
          const [showLevelBanner, setShowLevelBanner] = useState(false);
          const [power, setPower] = useState(0.5);
          
          const angleRef = useRef(0);
          const rotationRef = useRef(0);
          const obstaclesRef = useRef([]);
          const fansRef = useRef([]);
          const lastLevelRef = useRef(level);
          const netPhysicsRef = useRef(0);

          const CAMERA_SCALE = 0.92;
          const BALL_START_X = 120;
          const BALL_HEIGHT_FRACTION = 1/3;

          const ballRef = useRef({
            pos: { x: BALL_START_X, y: 300 },
            vel: { x: 0, y: 0 },
            radius: 14,
            isFlying: false,
            bounces: 0,
            scored: false
          });

          const hoopRef = useRef({ pos: { x: 960, y: 300 }, radius: 28, hitboxWidth: 40 });

          const resetBall = useCallback(() => {
            let h = canvasRef.current?.height || 600;
            const floorY = h - 60;
            const spawnY = floorY - (floorY * BALL_HEIGHT_FRACTION);
            
            ballRef.current = {
              pos: { x: BALL_START_X, y: spawnY },
              vel: { x: 0, y: 0 },
              radius: 14,
              isFlying: false,
              bounces: 0,
              scored: false
            };
            
            setInputState(InputState.SETTING_ANGLE);
            rotationRef.current = 0;
          }, []);

          // Initialize obstacles based on level (this is a condensed version)
          const initObstacles = useCallback((lvl, width, height) => {
            const obs = [];
            const floorY = height - 60;
            const midX = width / 2;
            const midY = height / 2;

            // Level-specific obstacles (condensed - includes all 20 levels)
            if (lvl === 1) {
              // Empty - tutorial
            } else if (lvl === 2) {
              obs.push({ pos: { x: midX - 100, y: midY }, width: 200, height: floorY - midY, isMoving: false, velocity: 0, range: 0, startPos: { x: midX - 100, y: midY }, color: '#1e293b', type: 'solid' });
            } else if (lvl === 3) {
              obs.push({ pos: { x: midX - 20, y: 50 }, width: 40, height: floorY - 200, isMoving: true, velocity: 0.003, range: 150, startPos: { x: midX - 20, y: 150 }, color: '#334155', type: 'solid', movementAxis: 'y' });
            } else if (lvl === 4) {
              obs.push({ pos: { x: midX, y: 0 }, width: 30, height: floorY - 140, isMoving: false, velocity: 0, range: 0, startPos: { x: midX, y: 0 }, color: '#0f172a', type: 'solid' });
              obs.push({ pos: { x: midX - 80, y: floorY - 20 }, width: 160, height: 20, isMoving: false, velocity: 0, range: 0, startPos: { x: midX - 80, y: floorY - 20 }, color: '#06b6d4', type: 'bounce' });
            } else if (lvl === 5) {
              obs.push({ pos: { x: width - 250, y: 120 }, width: 40, height: floorY - 120, isMoving: false, velocity: 0, range: 0, startPos: { x: width - 250, y: 120 }, color: '#1e293b', type: 'solid' });
              obs.push({ pos: { x: width - 450, y: 0 }, width: 350, height: 30, isMoving: false, velocity: 0, range: 0, startPos: { x: width - 450, y: 0 }, color: '#0891b2', type: 'bounce', angle: 0.1 });
            } else if (lvl === 6) {
              obs.push({ pos: { x: midX, y: 0 }, width: 40, height: midY - 60, isMoving: false, velocity: 0, range: 0, startPos: { x: midX, y: 0 }, color: '#1e293b', type: 'solid' });
              obs.push({ pos: { x: midX, y: midY + 60 }, width: 40, height: floorY - (midY + 60), isMoving: false, velocity: 0, range: 0, startPos: { x: midX, y: midY + 60 }, color: '#1e293b', type: 'solid' });
            } else if (lvl === 20) {
              const barrierX = 210;
              const barrierH = floorY - 120;
              const padX = 400;
              obs.push({ pos: { x: barrierX, y: 0 }, width: 25, height: barrierH, isMoving: false, velocity: 0, range: 0, startPos: { x: barrierX, y: 0 }, color: '#0f172a', type: 'solid' });
              obs.push({ pos: { x: barrierX, y: barrierH }, width: padX - barrierX, height: 25, isMoving: false, velocity: 0, range: 0, startPos: { x: barrierX, y: barrierH }, color: '#0f172a', type: 'solid' });
              obs.push({ pos: { x: 500, y: midY }, width: 30, height: 140, isMoving: true, velocity: 0.005, range: 180, startPos: { x: 500, y: midY }, color: '#1e293b', type: 'solid', movementAxis: 'y' });
              obs.push({ pos: { x: 820, y: midY }, width: 130, height: 25, isMoving: true, velocity: 0.012, range: 150, startPos: { x: 820, y: midY }, color: '#ef4444', type: 'solid', movementAxis: 'y' });
              obs.push({ pos: { x: padX, y: floorY - 20 }, width: width - padX, height: 20, isMoving: false, velocity: 0, range: 0, startPos: { x: padX, y: floorY - 20 }, color: '#06b6d4', type: 'bounce' });
              obs.push({ pos: { x: 450, y: 0 }, width: 250, height: 40, isMoving: false, velocity: 0, range: 0, startPos: { x: 450, y: 0 }, color: '#334155', type: 'solid' });
            }
            // Add more levels 7-19 as needed - this is a simplified version
            obstaclesRef.current = obs;
          }, []);

          const initFans = useCallback((width, height) => {
            const fans = [];
            const colors = ['#f87171', '#60a5fa', '#34d399', '#fbbf24', '#a78bfa', '#f472b6'];
            for (let tier = 0; tier < 4; tier++) {
              const tierY = height * 0.7 - (tier * 45);
              for (let x = -200; x < width - 100; x += 22) {
                if (Math.random() > 0.25) {
                  fans.push({ x: x + (Math.random() * 12 - 6), y: tierY - 18, color: colors[Math.floor(Math.random() * colors.length)], offset: Math.random() * Math.PI * 2 });
                }
              }
            }
            fansRef.current = fans;
          }, []);

          useEffect(() => {
            const handleResize = () => {
              if (containerRef.current && canvasRef.current) {
                const rect = containerRef.current.getBoundingClientRect();
                const w = Math.floor(rect.width);
                const h = Math.floor(rect.height);
                
                if (w < 1 || h < 1) return;

                canvasRef.current.width = w;
                canvasRef.current.height = h;
                
                hoopRef.current = { pos: { x: w - 90, y: h * 0.5 }, radius: 28, hitboxWidth: 40 };
                initObstacles(level, w, h);
                initFans(w, h);
                resetBall();
              }
            };
            handleResize();
            window.addEventListener('resize', handleResize);
            return () => window.removeEventListener('resize', handleResize);
          }, [level, initObstacles, initFans, resetBall]);

          useEffect(() => {
            if (level > lastLevelRef.current) {
              setShowLevelBanner(true);
              const timer = setTimeout(() => setShowLevelBanner(false), 2000);
              lastLevelRef.current = level;
              resetBall();
              return () => clearTimeout(timer);
            }
          }, [level, resetBall]);

          const handleMouseMove = (e) => {
            if (inputState !== InputState.SETTING_ANGLE) return;
            
            let clientX, clientY;
            if (e.touches && e.touches.length > 0) {
              clientX = e.touches[0].clientX;
              clientY = e.touches[0].clientY;
            } else {
              clientX = e.clientX;
              clientY = e.clientY;
            }

            if (containerRef.current) {
              const rect = containerRef.current.getBoundingClientRect();
              const x = (clientX - rect.left) / CAMERA_SCALE;
              const y = (clientY - rect.top) / CAMERA_SCALE;

              const dx = x - ballRef.current.pos.x;
              const dy = y - ballRef.current.pos.y;
              angleRef.current = Math.atan2(dy, dx);
            }
          };

          const handleContainerMouseDown = (e) => {
            if (inputState === InputState.SETTING_ANGLE) {
              setInputState(InputState.SETTING_POWER);
            }
          };

          const handleShoot = (e) => {
            e.stopPropagation();
            const maxVel = 26;
            const minVel = 10;
            const velocity = minVel + (power * (maxVel - minVel));
            ballRef.current.vel = { x: Math.cos(angleRef.current) * velocity, y: Math.sin(angleRef.current) * velocity };
            ballRef.current.isFlying = true;
            ballRef.current.bounces = 0;
            ballRef.current.scored = false;
            setInputState(InputState.FLYING);
          };

          const handleChangeAim = (e) => {
            e.stopPropagation();
            setInputState(InputState.SETTING_ANGLE);
          };

          const onPowerClick = (e) => {
            e.stopPropagation();
            if (inputState !== InputState.SETTING_POWER && inputState !== InputState.READY_TO_FIRE) return;
            const rect = e.currentTarget.getBoundingClientRect();
            const val = 1 - (e.clientY - rect.top) / rect.height;
            setPower(Math.min(1, Math.max(0, val)));
            if (inputState === InputState.SETTING_POWER) setInputState(InputState.READY_TO_FIRE);
          };

          // Main game loop
          useEffect(() => {
            const canvas = canvasRef.current;
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            if (!ctx) return;

            let animationFrameId;
            const BOUNCE_FACTOR = 0.75;
            const SPECIAL_BOUNCE = 1.25;
            const FRICTION = 0.99;

            const render = (time) => {
              ctx.clearRect(0, 0, canvas.width, canvas.height);

              const arenaGrad = ctx.createLinearGradient(0, 0, 0, canvas.height);
              arenaGrad.addColorStop(0, '#020617');
              arenaGrad.addColorStop(1, '#0f172a');
              ctx.fillStyle = arenaGrad;
              ctx.fillRect(0, 0, canvas.width, canvas.height);

              ctx.save();
              ctx.translate(canvas.width * (1 - CAMERA_SCALE), canvas.height * (1 - CAMERA_SCALE) / 2);
              ctx.scale(CAMERA_SCALE, CAMERA_SCALE);

              const floorY = canvas.height - 60;
              const wallX = canvas.width;

              netPhysicsRef.current *= 0.94;
              if (netPhysicsRef.current < 0.001) netPhysicsRef.current = 0;

              obstaclesRef.current.forEach(obs => {
                if (obs.isMoving) {
                  const offset = Math.sin(time * obs.velocity) * obs.range;
                  if (obs.movementAxis === 'y') {
                    obs.pos.y = obs.startPos.y + offset;
                  } else {
                    obs.pos.x = obs.startPos.x + offset;
                  }
                }
                if (obs.rotationSpeed) {
                  obs.angle = (obs.angle || 0) + obs.rotationSpeed;
                }
              });

              fansRef.current.forEach(fan => {
                const bob = Math.sin(time * 0.005 + fan.offset) * 3;
                ctx.fillStyle = fan.color;
                ctx.beginPath(); 
                ctx.arc(fan.x, fan.y + bob, 8, 0, Math.PI * 2); 
                ctx.fill();
                ctx.fillRect(fan.x - 6, fan.y + 10 + bob, 12, 10);
              });

              const woodGrad = ctx.createLinearGradient(0, floorY, 0, canvas.height);
              woodGrad.addColorStop(0, '#78350f');
              woodGrad.addColorStop(1, '#451a03');
              ctx.fillStyle = woodGrad;
              ctx.fillRect(-500, floorY, canvas.width + 1000, 500);

              const b = ballRef.current;
              const h = hoopRef.current;

              if (!b.isFlying) {
                b.pos.y = floorY - (floorY * BALL_HEIGHT_FRACTION);
                b.pos.x = BALL_START_X;
              }

              if (inputState === InputState.SETTING_ANGLE || inputState === InputState.SETTING_POWER || inputState === InputState.READY_TO_FIRE) {
                ctx.beginPath();
                ctx.setLineDash([10, 5]);
                ctx.strokeStyle = inputState === InputState.READY_TO_FIRE ? '#f97316' : 'rgba(255, 255, 255, 0.4)';
                ctx.lineWidth = 3;
                const length = 150 + (power * 100);
                ctx.moveTo(b.pos.x, b.pos.y);
                ctx.lineTo(b.pos.x + Math.cos(angleRef.current) * length, b.pos.y + Math.sin(angleRef.current) * length);
                ctx.stroke();
                ctx.setLineDash([]);
              }

              if (b.isFlying) {
                b.vel.y += gravity;
                b.pos.x += b.vel.x;
                b.pos.y += b.vel.y;
                rotationRef.current += b.vel.x * 0.05;

                // Boundary checks
                if (b.pos.y - b.radius < 10) { b.pos.y = b.radius + 10; b.vel.y *= -BOUNCE_FACTOR; b.bounces++; }
                if (b.pos.x + b.radius > wallX - 35) { b.pos.x = wallX - 35 - b.radius; b.vel.x *= -BOUNCE_FACTOR; b.bounces++; }
                if (b.pos.x - b.radius < -400) { b.pos.x = -400 + b.radius; b.vel.x *= -BOUNCE_FACTOR; b.bounces++; }
                if (b.pos.y + b.radius > floorY) {
                  b.pos.y = floorY - b.radius; 
                  b.vel.y *= -BOUNCE_FACTOR; 
                  b.vel.x *= FRICTION; 
                  b.bounces++;
                  if (b.bounces > 40 || (Math.abs(b.vel.y) < 0.2 && Math.abs(b.vel.x) < 0.2)) { 
                    if (!b.scored) onMiss(); 
                    resetBall(); 
                  }
                }

                // Obstacle collisions (simplified)
                obstaclesRef.current.forEach(obs => {
                  const angle = obs.angle || 0;
                  const dx = b.pos.x - (obs.pos.x + obs.width / 2);
                  const dy = b.pos.y - (obs.pos.y + obs.height / 2);
                  const cosA = Math.cos(-angle); 
                  const sinA = Math.sin(-angle);
                  const localX = dx * cosA - dy * sinA; 
                  const localY = dx * sinA + dy * cosA;
                  const halfW = obs.width / 2; 
                  const halfH = obs.height / 2;
                  const closestX = Math.max(-halfW, Math.min(localX, halfW));
                  const closestY = Math.max(-halfH, Math.min(localY, halfH));
                  const diffX = localX - closestX; 
                  const diffY = localY - closestY;
                  const distSq = diffX * diffX + diffY * diffY;
                  
                  if (distSq < b.radius * b.radius) {
                    const dist = Math.sqrt(distSq);
                    let nx, ny; 
                    if (dist > 0) { nx = diffX / dist; ny = diffY / dist; } 
                    else { nx = 0; ny = 1; }
                    const penetration = b.radius - dist;
                    const worldPushX = (nx * penetration) * Math.cos(angle) - (ny * penetration) * Math.sin(angle);
                    const worldPushY = (nx * penetration) * Math.sin(angle) + (ny * penetration) * Math.cos(angle);
                    b.pos.x += worldPushX; 
                    b.pos.y += worldPushY;
                    const localVelX = b.vel.x * cosA - b.vel.y * sinA; 
                    const localVelY = b.vel.x * sinA + b.vel.y * cosA;
                    const dot = localVelX * nx + localVelY * ny;
                    if (dot < 0) {
                      const bounce = obs.type === 'bounce' ? SPECIAL_BOUNCE : BOUNCE_FACTOR;
                      const refLocalVelX = (localVelX - 2 * dot * nx) * bounce; 
                      const refLocalVelY = (localVelY - 2 * dot * ny) * bounce;
                      b.vel.x = refLocalVelX * Math.cos(angle) - refLocalVelY * Math.sin(angle);
                      b.vel.y = refLocalVelX * Math.sin(angle) + refLocalVelY * Math.cos(angle);
                      b.bounces++;
                    }
                  }
                });

                // Backboard collision
                const boardX = h.pos.x + 35;
                if (b.pos.x + b.radius > boardX && b.pos.x - b.radius < boardX + 15 && b.pos.y > h.pos.y - 110 && b.pos.y < h.pos.y + 30) {
                  b.vel.x = -Math.abs(b.vel.x) * BOUNCE_FACTOR; 
                  b.pos.x = boardX - b.radius;
                }

                // Rim collision
                [{x: h.pos.x - h.radius, y: h.pos.y}, {x: h.pos.x + h.radius, y: h.pos.y}].forEach(p => {
                  const dx = b.pos.x - p.x; 
                  const dy = b.pos.y - p.y; 
                  const dist = Math.sqrt(dx * dx + dy * dy);
                  if (dist < b.radius + 3) {
                    const nx = dx / dist; 
                    const ny = dy / dist; 
                    const dot = b.vel.x * nx + b.vel.y * ny;
                    if (dot < 0) { 
                      b.vel.x = (b.vel.x - 2 * dot * nx) * BOUNCE_FACTOR; 
                      b.vel.y = (b.vel.y - 2 * dot * ny) * BOUNCE_FACTOR; 
                    }
                    b.pos.x = p.x + nx * (b.radius + 3); 
                    b.pos.y = p.y + ny * (b.radius + 3);
                  }
                });

                // Score detection
                if (!b.scored && b.vel.y > 0 && b.pos.y > h.pos.y && b.pos.y - b.vel.y <= h.pos.y) {
                  if (Math.abs(b.pos.x - h.pos.x) < h.radius) {
                    b.scored = true;
                    netPhysicsRef.current = 1.0;
                    onScore(Math.abs(b.pos.x - h.pos.x) < 8);
                  }
                }
              }

              // Draw backboard
              ctx.fillStyle = '#ffffff'; 
              ctx.strokeStyle = '#000000'; 
              ctx.lineWidth = 3;
              ctx.fillRect(h.pos.x + 40, h.pos.y - 110, 15, 140);
              ctx.strokeRect(h.pos.x + 40, h.pos.y - 110, 15, 140);
              
              // Draw net
              const netSwing = Math.sin(time * 0.02) * 15 * netPhysicsRef.current;
              const netDip = Math.abs(netSwing) * 0.4;
              ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)'; 
              ctx.lineWidth = 2;
              for (let i = -h.radius + 4; i < h.radius; i += 7) {
                ctx.beginPath();
                ctx.moveTo(h.pos.x + i, h.pos.y + 5);
                ctx.lineTo(h.pos.x + i * 0.6 + netSwing, h.pos.y + 35 + netDip);
                ctx.stroke();
              }

              // Draw rim
              ctx.strokeStyle = '#ea580c'; 
              ctx.lineWidth = 7;
              ctx.beginPath(); 
              ctx.ellipse(h.pos.x, h.pos.y, h.radius, 7, 0, 0, Math.PI * 2); 
              ctx.stroke();

              // Draw obstacles
              obstaclesRef.current.forEach(obs => {
                ctx.save(); 
                ctx.translate(obs.pos.x + obs.width / 2, obs.pos.y + obs.height / 2); 
                ctx.rotate(obs.angle || 0);
                if (obs.type === 'bounce') {
                  const pulse = Math.sin(time * 0.01) * 5;
                  ctx.fillStyle = '#0891b2'; 
                  ctx.fillRect(-obs.width / 2 - pulse / 2, -obs.height / 2 - pulse / 2, obs.width + pulse, obs.height + pulse);
                  ctx.strokeStyle = '#cffafe'; 
                  ctx.lineWidth = 3; 
                  ctx.strokeRect(-obs.width / 2, -obs.height / 2, obs.width, obs.height);
                } else {
                  ctx.fillStyle = obs.color; 
                  ctx.fillRect(-obs.width / 2, -obs.height / 2, obs.width, obs.height);
                  if (obs.isMoving || obs.rotationSpeed) { 
                    ctx.strokeStyle = '#ef4444'; 
                    ctx.lineWidth = 1; 
                    ctx.strokeRect(-obs.width / 2 - 2, -obs.height / 2 - 2, obs.width + 4, obs.height + 4); 
                  }
                }
                ctx.restore();
              });

              // Draw ball shadow
              ctx.fillStyle = 'rgba(0,0,0,0.3)'; 
              ctx.beginPath(); 
              ctx.ellipse(b.pos.x, floorY, b.radius * (1 - (floorY - b.pos.y) / 600), 5, 0, 0, Math.PI * 2); 
              ctx.fill();

              // Draw ball
              ctx.save(); 
              ctx.translate(b.pos.x, b.pos.y); 
              ctx.rotate(rotationRef.current);
              ctx.fillStyle = '#f97316'; 
              ctx.beginPath(); 
              ctx.arc(0, 0, b.radius, 0, Math.PI * 2); 
              ctx.fill();
              ctx.strokeStyle = '#431407'; 
              ctx.lineWidth = 1.5; 
              ctx.beginPath(); 
              ctx.arc(0, 0, b.radius, 0.3, 1.2); 
              ctx.stroke();
              ctx.restore();

              ctx.restore();
              animationFrameId = requestAnimationFrame(render);
            };

            animationFrameId = requestAnimationFrame(render);
            return () => cancelAnimationFrame(animationFrameId);
          }, [gravity, inputState, onMiss, onScore, resetBall, level, power]);

          // Render UI
          return React.createElement('div', {
            ref: containerRef,
            className: "w-full h-full relative cursor-crosshair touch-none select-none overflow-hidden",
            onMouseMove: handleMouseMove,
            onTouchMove: handleMouseMove,
            onMouseDown: handleContainerMouseDown
          },
            React.createElement('canvas', { ref: canvasRef, className: "w-full h-full block" }),
            
            showLevelBanner && React.createElement('div', { className: "absolute inset-0 flex items-center justify-center pointer-events-none z-30 bg-black/50 backdrop-blur-sm" },
              React.createElement('div', { className: "bg-white text-slate-900 px-10 py-10 rounded-3xl shadow-2xl border-8 border-orange-600 animate-bounce" },
                React.createElement('h2', { className: "text-6xl font-black italic tracking-tighter uppercase" }, `Level ${level}`)
              )
            ),

            React.createElement('div', { className: "absolute top-10 left-10 flex flex-col gap-6 items-start" },
              React.createElement('div', { className: "flex flex-col gap-1" },
                React.createElement('div', { className: `px-4 py-1 rounded-full font-black text-xs uppercase ${inputState === InputState.SETTING_ANGLE ? 'bg-orange-600 text-white' : 'bg-slate-200 text-slate-500'}` }, "1. AIM (Click Court)"),
                React.createElement('div', { className: `px-4 py-1 rounded-full font-black text-xs uppercase ${inputState === InputState.SETTING_POWER ? 'bg-orange-600 text-white' : 'bg-slate-200 text-slate-500'}` }, "2. SET POWER (Click Bar)"),
                React.createElement('div', { className: `px-4 py-1 rounded-full font-black text-xs uppercase ${inputState === InputState.READY_TO_FIRE ? 'bg-green-600 text-white animate-pulse' : 'bg-slate-200 text-slate-500'}` }, "3. FIRE")
              ),

              (inputState === InputState.SETTING_POWER || inputState === InputState.READY_TO_FIRE || inputState === InputState.SETTING_ANGLE) && React.createElement('div', { className: "flex flex-col items-center gap-2" },
                React.createElement('div', {
                  className: `w-10 h-64 border-4 rounded-xl relative overflow-hidden cursor-pointer shadow-xl transition-opacity ${inputState === InputState.SETTING_ANGLE ? 'opacity-30' : 'opacity-100'}`,
                  onMouseDown: onPowerClick,
                  style: { background: 'linear-gradient(to top, #fcd34d, #ea580c, #991b1b)' }
                },
                  React.createElement('div', { className: "absolute top-0 w-full bg-slate-100/40", style: { height: `${(1 - power) * 100}%` } }),
                  React.createElement('div', { className: "absolute w-full h-2 bg-white border-y-2 border-black", style: { bottom: `${power * 100}%` } })
                ),
                React.createElement('p', { className: "text-[10px] font-black uppercase text-slate-500" }, `Power ${Math.round(power * 100)}%`)
              )
            ),

            React.createElement('div', { className: "absolute bottom-10 right-10 flex flex-col items-center gap-4" },
              inputState === InputState.SETTING_ANGLE && React.createElement('div', { className: "bg-black/60 text-white px-8 py-4 rounded-full font-black text-xl uppercase shadow-2xl border-2 border-white/20 animate-pulse" }, "Click Court to Lock Aim"),
              
              inputState === InputState.READY_TO_FIRE && React.createElement('div', { className: "flex flex-col gap-4" },
                React.createElement('button', { className: "px-8 py-3 bg-slate-800 text-white rounded-xl font-bold uppercase text-xs hover:bg-slate-700 shadow-lg", onClick: handleChangeAim }, "Change Aim"),
                React.createElement('button', { className: "w-32 h-32 rounded-full border-4 border-white bg-green-600 text-white font-black text-xl uppercase shadow-xl hover:scale-110 active:scale-95 transition-all", onClick: handleShoot }, "FIRE!")
              ),

              inputState === InputState.SETTING_POWER && React.createElement('div', { className: "flex flex-col items-center gap-4" },
                React.createElement('button', { className: "px-8 py-3 bg-slate-800 text-white rounded-xl font-bold uppercase text-xs hover:bg-slate-700 shadow-lg", onClick: handleChangeAim }, "Back to Aim"),
                React.createElement('p', { className: "bg-black/80 text-white px-6 py-3 rounded-2xl font-bold text-sm uppercase animate-pulse" }, "Set Power on the bar")
              ),

              inputState === InputState.FLYING && React.createElement('button', { className: "group flex flex-col items-center gap-2", onClick: resetBall },
                React.createElement('div', { className: "bg-amber-500 hover:bg-amber-600 text-white w-20 h-20 rounded-full flex items-center justify-center shadow-2xl border-4 border-white transition-all hover:scale-105 active:scale-90" },
                  React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", className: "h-10 w-10", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor" },
                    React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 3, d: "M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" })
                  )
                ),
                React.createElement('p', { className: "text-amber-700 font-black text-xs uppercase tracking-widest bg-white/80 px-3 py-1 rounded-full" }, "Reset Shot")
              )
            )
          );
        };

        // Main App
        const App = () => {
          const [view, setView] = useState('MENU');
          const [gameState, setGameState] = useState({
            score: 0,
            attempts: 0,
            multiplier: 1,
            gravity: 0.6,
            eventActive: null,
            commentary: "Step up to the line. No pressure.",
            level: 1,
            scoreInLevel: 0
          });

          const handleSelectLevel = useCallback((level) => {
            setGameState(prev => ({
              ...prev,
              level,
              scoreInLevel: 0,
              commentary: `Level ${level}. Let's see some game.`
            }));
            setView('GAME');
          }, []);

          const handleScore = useCallback(async (isCritical) => {
            setGameState(prev => {
              const nextScoreInLevel = prev.scoreInLevel + 1;
              const leveledUp = nextScoreInLevel >= 1;
              const newLevel = leveledUp ? prev.level + 1 : prev.level;
              const newScoreInLevelFinal = leveledUp ? 0 : nextScoreInLevel;
              const addedScore = isCritical ? 3 : 2;
              const newTotalScore = prev.score + addedScore;

              if (leveledUp && prev.level === 20) {
                setView('WIN');
                return {
                  ...prev,
                  score: newTotalScore,
                  attempts: prev.attempts + 1,
                  level: 20,
                  scoreInLevel: 0
                };
              }

              const statusMsg = leveledUp ? `LEVEL UP` : (isCritical ? "SWISH" : "SCORED");
              
              fetchCommentary(statusMsg, newTotalScore).then(comm => {
                setGameState(current => ({ ...current, commentary: comm }));
              });

              return {
                ...prev,
                score: newTotalScore,
                attempts: prev.attempts + 1,
                level: newLevel,
                scoreInLevel: newScoreInLevelFinal
              };
            });
          }, []);

          const handleMiss = useCallback(async () => {
            setGameState(prev => {
              const newAttempts = prev.attempts + 1;
              
              fetchCommentary("MISSED", prev.score).then(comm => {
                setGameState(current => ({ ...current, commentary: comm }));
              });

              return { ...prev, attempts: newAttempts };
            });
          }, []);

          const handleGoToMenu = useCallback(() => {
            setView('MENU');
          }, []);

          const handlePlayAgain = useCallback(() => {
            setGameState({
              score: 0,
              attempts: 0,
              multiplier: 1,
              gravity: 0.6,
              eventActive: null,
              commentary: "Step up to the line. No pressure.",
              level: 1,
              scoreInLevel: 0
            });
            setView('MENU');
          }, []);

          return React.createElement('div', { className: "relative w-full h-screen bg-slate-100 flex flex-col items-center justify-start text-slate-900" },
            view === 'MENU' && React.createElement(Menu, { onSelectLevel: handleSelectLevel }),
            
            view === 'GAME' && React.createElement(React.Fragment, null,
              React.createElement(HUD, { gameState, isLoadingModifier: false, onBackToMenu: handleGoToMenu }),
              React.createElement('div', { className: "relative z-10 w-full max-w-4xl h-[65vh] border-4 border-white rounded-3xl bg-white shadow-2xl overflow-hidden mt-2" },
                React.createElement(GameView, { gravity: gameState.gravity, level: gameState.level, wind: 0, onScore: handleScore, onMiss: handleMiss })
              ),
              React.createElement('div', { className: "mt-8 text-slate-400 font-bold text-xs uppercase tracking-[0.2em]" },
                `Street Hoops Pro • Level ${gameState.level}`
              )
            ),

            view === 'WIN' && React.createElement(WinView, { score: gameState.score, attempts: gameState.attempts, onPlayAgain: handlePlayAgain })
          );
        };

        // Render
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(React.createElement(App));
    </script>
</body>
</html>
